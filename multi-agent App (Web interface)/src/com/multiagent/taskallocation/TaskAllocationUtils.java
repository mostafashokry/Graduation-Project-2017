package com.multiagent.taskallocation;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Vector;
import java.util.concurrent.TimeUnit;

import com.multiagent.pathplanning.PathPlanning;


public class TaskAllocationUtils {
	
	//private static final boolean True = false;
	static boolean PathPlanningBusy;
	
	public static boolean getFlage()
	{
		return PathPlanningBusy;
	}
	
	public static void setFlage()
	{
		PathPlanningBusy = false;
	}
	
	
	public static String dataWrite(int startX, int startY, int endX, int endY){
		while(PathPlanningBusy!=false)
		{
			System.out.println("Stuck writing in file");
			try {
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			continue;
		}
		System.out.println("PathPlanningBusy= " + PathPlanningBusy);
		PathPlanningBusy = true;
		System.out.println("PathPlanningBusyAfterChange= " + PathPlanningBusy);
		List<Integer> data = new ArrayList<>();
		data.add(startX);
		data.add(startY);
		data.add(endX);
		data.add(endY);
		String dataToWrite = data.toString();
		return dataToWrite;
		}
	
	public static List<Integer> stringToList(String s){
		Scanner scanner = new Scanner(s);
		List<Integer> list = new ArrayList<Integer>();
		while (scanner.hasNextInt()) {
		    list.add(scanner.nextInt());
		}
		return list;	
	}
	
	public static void writeAndPath(String write, String data, String path, int noRobot) throws IOException{
		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		String noRobotS = Integer.toString(noRobot);
		PathPlanning.writeInFile(write, noRobotS, data);
		PathPlanning.pathForRobot(path);
		try {
			TimeUnit.SECONDS.sleep(1);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		PathPlanningBusy = false;
		}
	
	//the function that calculate the length of the path generated by path planning
	public static int getLength( List<Integer> Vx , List<Integer> Vy )
	{
		int pathlength=0;
		int vecsize = Vx.size();
		for(int i=0 ; i<vecsize-1 ; i++)
		{
			pathlength = pathlength + Math.abs(Vy.get(i)-Vy.get(i+1));
			pathlength = pathlength + Math.abs(Vx.get(i)-Vx.get(i+1));
//			if(Vx.get(i)==Vx.get(i+1))
//			{
//				pathlength = pathlength + Math.abs(Vy.get(i)-Vy.get(i+1));
//				System.out.println("pathlength ix=" + pathlength);
//			}
//			else if (Vy.get(i)==Vy.get(i+1))
//			{
//				pathlength = pathlength + Math.abs(Vx.get(i)-Vx.get(i+1));
//				System.out.println("pathlength iy=" + pathlength);
//			}
		}
		System.out.println("pathlength total=" + pathlength);
		return pathlength;
	}
	
	public static int getPathLength(List<String> dataToRead){
		int temp =0;
		System.out.println("first line: "+dataToRead.get(0));
		String dataX = dataToRead.get(0).replace(",", " ");
		String dataY = dataToRead.get(1).replace(",", " ");
		System.out.println("dataX: "+dataX);
		List<Integer> vx = stringToList(dataX);
		List<Integer> vy = stringToList(dataY);
		temp = getLength(vx,vy);
		return temp;
	}
	
	public static int getTheBestRobotNumber(int SizeY , int startY, int no_Robot)
	{
		int thebestrobotnumber=1;
		int step= SizeY/no_Robot;
		int temp=step;
		for(int i=0;i<no_Robot ; i++)
		{
			thebestrobotnumber=i+1; //to start from 1 to the no_Robot
			if(step>=startY)
			{
				break;
			}
			step=step+temp;
		}
		return thebestrobotnumber;
	}
	
	public static String shiftPath(String s , int shift)
	{
		String ss;
		int n=0;
		ss=s;
		s="";
		char ch;
		for(int i=0 ; i<ss.length(); i++)
		{
			ch=ss.charAt(i);
			if(ch==' ')
			{
				n=n+shift;
				s=s+n+" ";
				n=0;
				continue;
			}
			n=Character.getNumericValue(ch)+n*10;
		}
		n=n+shift;
		s=s+n+" ";
		
		return s;
	}
	
//	public static Vector<Integer> listToVector(List<Integer> list){
//		Vector<Integer> v = new Vector<Integer>();	
//		for(int i=0; i< list.size(); i++){
//			v.add(list.get(i));
//		}
//		return v;
//		
//	}
	
	
}
