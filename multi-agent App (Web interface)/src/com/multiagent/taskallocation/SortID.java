package com.multiagent.taskallocation;

import c.beans.robot;
import db.connection.mySQLConnUtils;

 
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
 
import com.multiagent.pathplanning.PathPlanning;
import com.multiagent.robot.RobotUtils;

import java.io.IOException;
import java.lang.*;
import java.sql.Connection;
import java.sql.SQLException;

public class SortID {
	/**
	 *
	 * @author Mahmoud Talaat Rady
	 *
	 *we need to assign the task for the best available robot
	 *
	 *We could consider the inputs as 1-no_Robot
	 *                                2-Map Size (X & Y)
	 *                                3-start_X , start_Y
	 *                                4-end_X , end_Y
	 *
	 */
	//package com.multiagent.taskallocation;
	 

	 
     
	    final static int no_Robot=3;                     //No Of Robots in map
	    final static int X=18;                          //Map size in X
	    final static int Y=18;                         //Map size in Y
	                                        //this Locations Could be input for the class
	    final static int start_X=2;                     //Object Location in X
	    final static int start_Y=6;                    //Object Location in Y
	    static int feedpos_X=0;                    //Feedback from the rasberry
	    static int feedpos_Y=0;                    //Feedback from the rasberry
	    final static int end_X=9;                     //Goal Location in X
	    final static int end_Y=9;                    //Goal Location in Y
	   
	    static int[] arr_Available = new int[no_Robot];                  //array for Robots to know which is available
	    static int[] arr_State = new int[no_Robot];                     //array for each robot state 0 ,1 ,2 or 3
	    static int[][] arr_Parking = new int[no_Robot][2];             //array of the parking Location for each Robot
	    static int[] arr_ID = new int[no_Robot];               //array of the parking Location for each Robot
	    //---------------------------------------------------------------------------------------------------------------------
	    static int[] old_arr_Available = new int[no_Robot];                  //array for Robots to know which is available
	    static int[] old_arr_State = new int[no_Robot];                     //array for each robot state 0 ,1 ,2 or 3
	    static int[][] old_arr_Parking = new int[no_Robot][2];             //array of the parking Location for each Robot
	    static int[] old_arr_ID = new int[no_Robot];               //array of the parking Location for each Robot
	    //---------------------------------------------------------------------------------------------------------------------
	    static Vector<Integer> Vx = new Vector<Integer>();                     //the position vector for x generated by path planing
	    static Vector<Integer> Vy = new Vector<Integer>();                    //the position vector for y generated by path planing
	   
	   
	   
	   
	    // this function get the number of robot that have the start point in his area (start numbering from 1)
	    public static int getTheBestRobotNumber(int SizeY , int startY)
	    {
	        int thebestrobotnumber=1;
	        int step= SizeY/no_Robot;
	        int temp=step;
	        for(int i=0;i<no_Robot ; i++)
	        {
	            thebestrobotnumber=i+1; //to start from 1 to the no_Robot
	            if(step>=startY)
	            {
	                break;
	            }
	            step=step+temp;
	        }
	        return thebestrobotnumber;
	    }
	   
	   
	    //the function that calculate the length of the path generated by path planning
	    public static int getLength( Vector<Integer> Vx , Vector<Integer> Vy )
	    {
	        int pathlength=0;
	        int vecsize = Vx.size();
	        for(int i=0 ; i<vecsize-1 ; i++)
	        {
	            if(Vx.get(i)==Vx.get(i+1))
	            {
	                pathlength = pathlength + Math.abs(Vy.get(i)-Vy.get(i+1));
	            }
	            else if (Vy.get(i)==Vy.get(i+1))
	            {
	                pathlength = pathlength + Math.abs(Vx.get(i)-Vx.get(i+1));
	            }
	        }
	       
	        return pathlength;
	    }
	 
	   
	    // the main function
	    public static void main(String[] args) throws ClassNotFoundException, SQLException, IOException
	    {
	        Connection conn = mySQLConnUtils.getMySQLConnection();
	        int cnt_Available = 0;                           //Number of available robots
	        int thebestrobot;                           //The best robot number
	        int theminpath=100000;                     //the min path length
	        int temp;                                 //use this to compare each path length with another one
	        int robot = 0;                               //the best robot that we need to assign the task to
	        int flagoutofparking=0;                 //his value became 1 if there's any robot stop out of his parking area
	        List<robot> r = RobotUtils.getRobotData(conn);
	        int countList = r.size();
	        thebestrobot=getTheBestRobotNumber(Y,start_Y);
	        System.out.println("The thebestrobot value is " + thebestrobot);
	       
	        for(int i=0 ; i< countList ; i++)
	        {
	            //connect to database to get the availability ,the parking location and state of each robot.
	            // count the number of available robots (cnt_Available)
	            //the next assignment instead of getting this data form here
	           
	            old_arr_ID[i]=r.get(i).getR_ID();
	            old_arr_Available[i]=r.get(i).getAVAILITY();
	            old_arr_State[i] = r.get(i).getstatus();
	            old_arr_Parking[i][0] = r.get(i).getparkingX();
	            old_arr_Parking[i][1] = r.get(i).getparkingY();
	            if(old_arr_Available[i] == 1)
	            {
	                cnt_Available++;
	            }
	        }
	       
	        //-----------------------------------------Connector------------------------------------------------
	        //to sort the data from db with respect to Y location
	        //--------------------------------------------------------------------------------------------------
	        int c=0;
	        Vector<Integer> sortcount = new Vector<Integer>();
	        for (int i=0; i<no_Robot; i++)
	        {
	             c=0;
	             for (int j=0; j<no_Robot; j++)
	             {
	                 if(old_arr_Parking[i][1]>old_arr_Parking[j][1])
	                 {
	                     c++;
	                 }
	             }
	             sortcount.addElement(c);
	         }
	        //--------------------------------------------------------------------------------------------------
	        for (int i=0,j; i<sortcount.size(); i++)
	        {  
	            j=sortcount.get(i);
	            arr_ID[j]=old_arr_ID[i];
	            arr_Available[j]=old_arr_Available[i];
	            arr_State[j]=old_arr_State[i];
	            arr_Parking[j][0]=old_arr_Parking[i][0];
	            arr_Parking[j][1]=old_arr_Parking[i][1];
	        }
	        //--------------------------------------------------------------------------------------------------
	        //--------------------------------------------------------------------------------------------------
	       
	//the assignment
	//-------------------------------------------------------------------------------------------------------------
	        //for Example 1 is Available and 0 is not
//	      arr_Available[0]=1;
//	      arr_Available[1]=0;
//	      arr_Available[2]=1;
	       
	        //for Example state 0 ,1 ,2 or 3
//	      arr_State[0]=0;
//	      arr_State[1]=3;
//	      arr_State[2]=0;
	       
	        //for Example the Available Robots are 
//	      cnt_Available=2;
	       
	        //for Example the parking location for each robot
//	      arr_Parking[0][0]=1;
//	      arr_Parking[0][1]=3;
//	     
//	      arr_Parking[1][0]=1;
//	      arr_Parking[1][1]=9;
//	     
//	      arr_Parking[2][0]=1;
//	      arr_Parking[2][1]=16;
//	     
	        //for Example the Position matrix that the path planning function get
	         Vx.addElement(1);
	         Vy.addElement(1);
	           
	         Vx.addElement(11);
	         Vy.addElement(1);
	           
	         Vx.addElement(11);
	         Vy.addElement(8);
	           
	         Vx.addElement(8);
	         Vy.addElement(8);
	           
	         Vx.addElement(8);
	         Vy.addElement(4);
	               
	//-------------------------------------------------------------------------------------------------------------
	       
	        //if the best robot is the first or the last so only check for 2   
	        if(thebestrobot==1)
	        {
	            System.out.println("i am here");
	            if(arr_State[thebestrobot-1]==3)
	            {
	                //stop the robot in his position and get his position
	                //change a flag here ,cause there's a robot that isn't stopping in his parking
	                feedpos_X=6;
	                feedpos_Y=4;
	               
	                flagoutofparking=1;
	                //insert his position(x,y) and the start location(x,y) into the input file
	                List<Integer> data = new ArrayList<>();
	                data.add(feedpos_X);
	                data.add(feedpos_Y);
	                data.add(start_X);
	                data.add(start_Y);
//	              String s = String.
	                String dataS = data.toString();
	 
	                //PathPlanning.writeInFile("F:\\Courses\\Collage\\Graduation Project\\Software Section\\GradPro-master\\V7\\V7\\Input_Start_and_End_Points.txt", dataS);
	                //call the path planning function to get the path
	                PathPlanning.pathForRobot("F:\\Courses\\Collage\\Graduation Project\\Software Section\\GradPro-master\\V7\\V7\\bin\\Debug\\TestPathPlanning.exe");
	               
	               
	                //get the position matrix from the output file of the path planning ----> toqa
	               
	                temp = getLength(Vx,Vy);
	                if(theminpath > temp)
	                {
	                    theminpath= temp;
	                    robot=thebestrobot;
	                }
	            }
	            for(int i=0; i<2 ;i++)
	            {
	                if(arr_Available[i] == 1)
	                {
	                    // insert the parking location(x,y) and the start location(x,y) into the input file
	                    //call the path planning function to get the path
	                    // get the position matrix from the output file of the path planning
	                    System.out.println("i am here again");
	                    temp = getLength(Vx,Vy);
	                    if(theminpath > temp)
	                    {
	                        theminpath= temp;
	                        robot=i+1;
	                    }
	                }
	            }
	        }
	       
	        else if(thebestrobot==no_Robot)
	        {
	            if(arr_State[thebestrobot-1]==3)
	            {
	                //stop the robot in his position and get his position
	                //change a flag here ,cause there's a robot that isn't stopping in his parking
	                flagoutofparking=1;
	                //insert his position(x,y) and the start location(x,y) into the input file
	                //call the path planning function to get the path
	                //get the position matrix from the output file of the path planning
	               
	                temp = getLength(Vx,Vy);
	                if(theminpath > temp)
	                {
	                    theminpath= temp;
	                    robot=thebestrobot;
	                }
	            }
	            for(int i=0; i<2 ;i++)
	            {
	                if(arr_Available[no_Robot-1-i] == 1)
	                {
	                    // insert the parking location(x,y) and the start location(x,y) into the input file
	                    //call the path planning function to get the path
	                    // get the position matrix from the output file of the path planning
	                }
	                temp = getLength(Vx,Vy);
	                if(theminpath > temp)
	                {
	                    theminpath= temp;
	                    robot=no_Robot-i;
	                }
	            }
	        }
	       
	        //if the best robot is not the first and not the last ,so w need to check 3 times
	        else
	        {
	            if(arr_State[thebestrobot-1]==3)
	            {
	                //stop the robot in his position and get his position
	                //change a flag here ,cause there's a robot that isn't stopping in his parking
	                flagoutofparking=1;
	                //insert his position(x,y) and the start location(x,y) into the input file
	                //call the path planning function to get the path
	                //get the position matrix from the output file of the path planning
	               
	                temp = getLength(Vx,Vy);
	                if(theminpath > temp)
	                {
	                    theminpath= temp;
	                    robot=thebestrobot;
	                }
	            }
	            for(int i=1; i<=3 ;i++)
	            {
	                //if the best is number 1 so [   2+1-1=(2) 2+1-2=(1) 2+1-3=(0)   ] and so on
	                if(arr_Available[thebestrobot+1-i] == 1)
	                {
	                    // insert the parking location(x,y) and the start location(x,y) into the input file
	                    //call the path planning function to get the path
	                    // get the position matrix from the output file of the path planning
	                }
	                temp = getLength(Vx,Vy);
	                if(theminpath > temp)
	                {
	                    theminpath= temp;
	                    robot=thebestrobot+2-i;
	                }
	            }
	        }
	       
	        if(robot != thebestrobot)
	        {
	            //move thebestrobot to his parking
	            //call path planning
	            //change a flag here ,cause there's a robot that isn't stopping in his parking
	            flagoutofparking=0;
	        }
	       
	        //must have at least one available to continue
	        while(cnt_Available == 0)
	        {
	        // call task allocation again
	        }      
	       
	    System.out.println("The best robot is " + robot);
	    //we could change the name of the main function to taskAllocation and make it return int(robot number to be assigned)
	    //return robot ;
	    }
	 
	}


